Міністерство освіти і науки України
Харківський національний університет радіоелектроніки



Кафедра програмної інженерії





Звіт
з практичної роботи №2
з дисципліни  «Аналіз та рефакторінг коду»
на тему «Методи рефакторингу коду програмного забезпечення»





Виконала:						                                    Перевірив:
Ст. гр. ПЗПІ-22-8                                  	    ст. викл. Сокорчук І. П.
Товстуха І. К. 






Харків 2024

2.1 Мета роботи

Мета роботи полягає у глибокому вивченні та практичному застосуванні методів рефакторингу коду.

2.2 Хід роботи

	2.2.1 Посилання на YouTube

	URL: 

	2.2.2 Вступ

Рефакторинг — це процес покращення структури існуючого коду без зміни його функціональності. Це важливий етап у розробці програмного забезпечення, 
оскільки дозволяє підвищити читабельність, спрощує підтримку і розширення коду. Одним із важливих аспектів рефакторингу є застосування певних методів, 
які допомагають вирішити поширені проблеми в коді, такі як дублювання, складність та нечіткість логіки. 
Три обрані методи рефакторингу: 
Inline Method — цей метод використовується для того, щоб замінити виклики методів, які містять дуже просту або повторювану логіку, без істотного покращення 
структури. Цей метод дозволяє зробити код компактнішим, прибравши зайві функції, що не додають цінності. 
Introduce Explaining Variable — цей метод полягає в додаванні тимчасових змінних, щоб пояснити складні вирази. Це робить код більш зрозумілим, 
оскільки складні умови чи операції розбиваються на простіші частини, що описуються зрозумілими змінними. 
Split Temporary Variable — цей метод використовується, коли одна змінна зберігає кілька різних значень протягом свого життєвого циклу. Метод передбачає розділення 
такої змінної на кілька окремих змінних, що зберігають конкретні значення в різних частинах обчислень, що робить код прозорішим і зменшує ризик помилок.

2.3 Методи рефакторінгу

  2.3.1 Inline Method

Метод Inline Method полягає в тому, щоб перенести логіку з окремих функцій безпосередньо в основну функцію, де ці обчислення використовуються. Це дозволяє 
зменшити кількість зайвих функцій і полегшити підтримку коду, адже вся логіка знаходиться в одному місці.

Код до рефакторингу:
1: function calculateOrderTotal(order) {
2: 	const subtotal = calculateSubtotal(order);
3: 	const tax = calculateTax(subtotal);
4: 	const shippingCost = calculateShippingCost(order);
5: 	
6: 	return subtotal + tax + shippingCost;
7: }
8: 
9: function calculateSubtotal(order) {
10: 	let subtotal = 0;
11: 	for (let i = 0; i < order.items.length; i++) {
12: 			subtotal += order.items[i].price * order.items[i].quantity;
13: 	}
14: 	return subtotal;
15: }
16: 
17: function calculateTax(subtotal) {
18: 	return subtotal * 0.15;
19: }
20: 
21: function calculateShippingCost(order) {
22: 	let shippingCost = 0;
23: 	if (order.items.length > 10) {
24: 			shippingCost = 20;
25: 	} else {
26: 			shippingCost = 10;
27: 	}
28: 	return shippingCost;
29: }

Опис проблеми:
У коді, який ми розглядаємо, є кілька функцій, які виконують подібні обчислення на однакових або схожих даних, зокрема для обчислення різних аспектів вартості 
замовлення: підсумкової ціни товарів, податку та вартості доставки. В цих функціях є невелике дублювання коду, і використання окремих методів для кожної операції 
виглядає надмірним.
Якщо ми зберігаємо початкову версію коду, це може призвести до кількох проблем:
1.	Дублювання коду: Оскільки різні функції виконують схожі операції, будь-яка зміна в одному з методів потребує внесення змін в кілька місць.
2.	Зниження читабельності: Множинні методи, які виконують подібні операції, додають складності в розуміння того, як працює програма.
3.	Труднощі при підтримці та розширенні: З часом, якщо функціональність збільшується, код стає важким для підтримки, оскільки потрібно постійно оновлювати кілька 
місць, де обчислюються різні аспекти вартості.
Метод рефакторингу: Inline Method дозволить зменшити кількість зайвих функцій, об'єднавши їхній код безпосередньо в місцях виклику. Це дозволить усунути дублювання, 
спростити структуру програми і покращити її підтримуваність.

Код після рефакторингу:
1: function calculateOrderTotal(order) {
2: 	let subtotal = 0;
3: 	for (let i = 0; i < order.items.length; i++) {
4: 			subtotal += order.items[i].price * order.items[i].quantity;
5: 	}
6: 
7: 	const tax = subtotal * 0.15;
8: 
9: 	let shippingCost = 0;
10: 	if (order.items.length > 10) {
11: 			shippingCost = 20;
12: 	} else {
13: 			shippingCost = 10;
14: 	}
15: 
16: 	return subtotal + tax + shippingCost;
17: }

Опис змін:
1.	Логіка обчислення підсумкової вартості тепер знаходиться безпосередньо у функції calculateOrderTotal.
2.	Ми прибрали окремі функції calculateSubtotal, calculateTax і calculateShippingCost, які тепер стали частиною основної функції.

Переваги отриманого коду після застосування методу
1.	Зменшення дублікатів коду: Тепер обчислення кожного елемента (підсумок, податок, доставка) знаходяться в одному місці, що зменшує повторення логіки.
2.	Покращення читабельності: Користувач або розробник, який читає цей код, може одразу побачити весь процес обчислення вартості замовлення, не переходячи між 
різними функціями.
3.	Зниження складності: Код став простіший, оскільки тепер немає потреби у відокремлених методах, що знижує складність підтримки та тестування.
4.	Покращена гнучкість: Всі зміни у логіці обчислення вартості замовлення тепер можна робити в одному місці, що знижує ймовірність помилок.

Висновок:
Метод Inline Method є ефективним для спрощення коду, коли кілька функцій виконують схожі операції. Він зменшує дублювання коду, покращує читабельність та підвищує 
ефективність підтримки. Однак слід обережно застосовувати його у випадках, коли код дуже великий або складний, оскільки занадто велика функція може стати важкою 
для розуміння.

2.3.2 Introduce Explaining Variable

Метод Introduce Explaining Variable дозволяє покращити читабельність коду, розбиваючи складні умови на зрозумілі змінні. Кожна змінна повинна мати описове ім'я, 
що чітко вказує, яку саме умову або частину логіки вона представляє.

Код до рефакторингу:
1: function calculateBonus(order, isPremiumCustomer) {
2: 	return (order.totalAmount > 500) 
3: 			? (isPremiumCustomer 
4: 					? order.totalAmount * 0.2 
5: 					: order.totalAmount * 0.1) 
6: 			: (order.totalAmount > 200 
7: 					? order.totalAmount * 0.05 
8: 					: 0);
9: }
10: 
11: let order = { 
12: 	totalAmount: 600, 
13: 	itemsCount: 3 
14: };
15: let isPremiumCustomer = true;
16: let bonus = calculateBonus(order, isPremiumCustomer);


Опис проблеми:
У коді, який ми розглядаємо, є кілька умовних виразів, що виконують обчислення на однакових або схожих даних, зокрема для визначення розміру бонусу в залежності 
від суми замовлення та статусу клієнта. В цих умовах є невелике дублювання коду, що ускладнює розуміння логіки обчислення бонусу. Використання вкладених тернарних 
операторів або складних умов для кожної операції може виглядати надмірним, що ускладнює зміну та підтримку коду в майбутньому.
Якщо ми зберігаємо початкову версію коду, це може призвести до кількох проблем:
1.	Низька читабельність: Вирази, що складаються з кількох операцій і умов, можуть бути складними для сприйняття.
2.	Труднощі при зміні логіки: Якщо вирази використовуються кілька разів, зміни в них можуть вимагати коригування в багатьох місцях.
3.	Невизначена логіка: Складні вирази можуть бути не до кінця зрозумілими для інших розробників, що ускладнює співпрацю і подальший розвиток коду.
Метод Introduce Explaining Variable допомагає зробити такі вирази більш зрозумілими, розділяючи складні вирази на окремі, чітко описані змінні. 
Це дозволяє покращити читабельність коду та зменшити дублювання логіки.


Код після рефакторингу:
1: function calculateBonus(order, isPremiumCustomer) {
2: 	const isLargeOrder = order.totalAmount > 500;
3: 	const isMediumOrder = order.totalAmount > 200;
4: 	const isPremiumCustomerEligible = isPremiumCustomer;
5: 
6: 	let bonusPercentage = 0;
7: 	if (isLargeOrder) {
8: 			bonusPercentage = isPremiumCustomerEligible ? 0.2 : 0.1;
9: 	} else if (isMediumOrder) {
10: 			bonusPercentage = 0.05;
11: 	}
12: 
13: 	const bonusAmount = order.totalAmount * bonusPercentage;
14: 	return bonusAmount;
15: }
16: 
17: let order = { totalAmount: 600, itemsCount: 3 };
18: let isPremiumCustomer = true;
19: let bonus = calculateBonus(order, isPremiumCustomer);

Опис змін:
1.	Ми створили змінні isLargeOrder, isMediumOrder, та isPremiumCustomerEligible, що чітко пояснюють умови.
2.	Встановили змінну bonusPercentage, яка визначає відсоток бонусу в залежності від умов.
3.	Замінили вкладені тернарні оператори на просту структуру умов, що значно покращує читабельність.
4.	Обчислення бонусу тепер зберігається в змінній bonusAmount, що робить фінальний розрахунок зрозумілим і зрозумілим.

Переваги отриманого коду після застосування методу
1.	Покращена читабельність: Змінні isLargeOrder, isMediumOrder, isPremiumCustomerEligible чітко пояснюють, які умови перевіряються. Замість вкладених тернарних 
операторів, логіка обчислення стала прозорою.
2.	Зменшення складності: Логіка розбита на проміжні змінні, що робить код значно легшим для розуміння.
3.	Підтримуваність: Якщо в майбутньому потрібно змінити умови бонусу (наприклад, змінити поріг для великого замовлення або відсоток для преміум-клієнтів), 
зміни потрібно буде внести лише в одну частину коду.
4.	Логічна ізоляція: Кожен етап обчислення бонусу має свою окрему змінну, що робить код більш структурованим і дозволяє легше тестувати окремі частини логіки.


Висновок:
Метод Introduce Explaining Variable допомагає значно покращити читабельність та підтримуваність коду, розбиваючи складні вирази на простіші змінні, кожна з яких 
має чітке значення. Це робить код більш зрозумілим, зменшує дублювання і полегшує внесення змін у майбутньому. Такі рефакторинги є корисними в проектах, де умови 
складні або змінюються з часом.

2.3.3 Split Temporary Variable

Метод Split Temporary Variable допомагає розділити одну змінну на кілька змінних, кожна з яких відповідає за один етап обчислення. Це дозволяє зробити код більш 
прозорим і зрозумілим, оскільки кожна змінна тепер виконує лише одну роль.

Код до рефакторингу:
1: function calculateFinalPrice(order) {
2: 	let price = order.basePrice;
3: 	price = price - order.discount;
4: 	price = price + order.tax;
5: 	price = price + order.shipping;
6: 	return price;
7: }
8: 
9: let order = { basePrice: 200, 
10: 	discount: 20, 
11: 	tax: 15, 
12: 	shipping: 10 };
13: let finalPrice = calculateFinalPrice(order);


Опис проблеми:
У коді, який ми розглядаємо, є випадки, коли одна змінна використовується для зберігання декількох різних значень протягом свого життєвого циклу. Це може призвести 
до плутанини, оскільки одна змінна виконує кілька ролей, і не завжди очевидно, яку саме роль вона відіграє в конкретному місці коду. В таких ситуаціях метод 
Split Temporary Variable є корисним. Він полягає в розділенні змінної, що використовується для зберігання різних значень, на кілька змінних, кожна з яких буде 
відповідати за одну чітко визначену роль.

Якщо ми зберігаємо початкову версію коду, це може призвести до кількох проблем:
1.	Невизначеність ролі змінної: Якщо змінна змінює своє значення кілька разів в межах одного методу, може бути не зовсім зрозуміло, для чого вона використовується.
2.	Плутанина при зміні значення: Використання однієї змінної для різних значень може призвести до помилок, якщо змінна оновлюється не в тому контексті.
3.	Зниження читабельності: Код стає важким для сприйняття, якщо одна змінна має кілька призначень.
Метод рефакторингу Split Temporary Variable полягає в тому, щоб розділити одну змінну на кілька змінних з чіткими іменами, кожна з яких буде відповідати за своє 
конкретне значення або обчислення.

Код після рефакторингу:
1: function calculateFinalPrice(order) {
2: 	let basePrice = order.basePrice;
3: 	let discountAmount = order.discount;
4: 	let taxAmount = order.tax;
5: 	let shippingAmount = order.shipping;
6: 
7: 	let priceAfterDiscount = basePrice - discountAmount;
8: 	let priceAfterTax = priceAfterDiscount + taxAmount;
9: 	let finalPrice = priceAfterTax + shippingAmount;
10: 
11: 	return finalPrice;
12: }
13: 
14: let order = { basePrice: 200, 
15: 	discount: 20, 
16: 	tax: 15, 
17: 	shipping: 10 };
18: let finalPrice = calculateFinalPrice(order);


Опис змін:
1.	Ми розділили змінну price на кілька чітко визначених змінних: basePrice, discountAmount, taxAmount, shippingAmount, priceAfterDiscount, priceAfterTax, 
і finalPrice.
2.	Кожна змінна тепер має чітке значення, яке зберігається на певному етапі обчислення.
3.	Це дозволяє зрозуміти, як саме формується фінальна ціна, і легко змінювати або доповнювати логіку.

Переваги отриманого коду після застосування методу
1.	Покращена читабельність: Тепер ми чітко бачимо, на якому етапі змінюється ціна: після знижки, після податку і після доставки. Це робить код зрозумілішим.
2.	Зменшення складності: Код став менш складним для сприйняття, оскільки кожна змінна має своє призначення, і немає плутанини в її значеннях.
3.	Чітка структура: Розподіл змінних дозволяє створити чітку структуру для кожного етапу обчислення, що робить код більш організованим і зручним для розвитку.
4.	Гнучкість в зміні логіки: Зміни в обчисленнях на кожному етапі можна робити без ризику порушити інші частини коду.
5.	Легкість в оновленнях: Тепер, якщо в майбутньому потрібно змінити умови для обчислення знижки чи податку, зміни будуть локалізовані на конкретних змінних, 
що значно полегшує підтримку коду.


Висновок:
Метод Split Temporary Variable є дуже корисним, коли одна змінна використовується для кількох етапів обчислення. Розділення цієї змінної на кілька чітко визначених 
змінних дозволяє зробити код більш зрозумілим, простим для підтримки і тестування. Це дозволяє уникнути плутанини та знижує ймовірність помилок при подальших змінах 
в коді.


Загальні висновки:
Рефакторинг коду значно покращив його якість, зробивши його більш читабельним, зрозумілим та підтримуваним. Застосування методів рефакторингу, таких як 
Inline Method, Introduce Explaining Variable та Split Temporary Variable, дозволило зменшити складність і уникнути дублювання коду. У результаті, кожен етап 
обчислень став чітко визначеним, що зменшило ймовірність виникнення помилок і полегшило тестування та внесення змін. Усі ці зміни підвищили ясність логіки коду, 
що дозволяє розробникам краще розуміти, як відбуваються обчислення та які умови застосовуються на різних етапах. Заміна складних і нечитабельних виразів на більш 
структуровані та зрозумілі дозволила не лише покращити сприйняття коду, а й зробити його гнучким для майбутніх змін. 
У цілому рефакторинг значно підвищує підтримуваність коду, знижує його складність і робить його більш адаптованим до змін та доповнень, що є важливим для розвитку 
програмного забезпечення в довгостроковій перспективі.


Використані джерела:
1. “Refactoring: Improving the Design of Existing Code” by Martin Fowler, Kent Beck (Contributor), John Brant (Contributor), William Opdyke, don Roberts 1999.
2. “Refactoring Guru” https://refactoring.guru/ru
3. “Refactoring” https://refactoring.com/


Додаток А

 
Рисунок А.1 – Титульний слайд


Рисунок А.2 – Слайд зі змістом


Рисунок А.3 – Слайд зі вступом

 
Рисунок А.4 – Слайд з методом «Inline Method», код до рефакторингу 

 
Рисунок А.5 – Слайд з методом «Inline Method», код після рефакторингу 


Рисунок А.6 – Слайд з методом «Introduce Explaining Variable», код до рефакторингу 


Рисунок А.7 – Слайд з методом «Introduce Explaining Variable», код після рефакторингу 


Рисунок А.8 – Слайд з методом «Split Temporary Variable», код до рефакторингу 


Рисунок А.9 – Слайд з методом «Split Temporary Variable», код після рефакторингу 


Рисунок А.10 – Слайд з висновками

 
Рисунок А.11 – Слайд зі списком використаних джерел
