МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ


Кафедра "Програмної інженерії"




ЗВІТ
З лабораторної роботи №2
з дисципліни
"Аналіз та рефакторинг коду"



Виконав:                                                                                                  Перевірив                      
ст. гр. ПЗПІ-22-8                                                                      ст. викладач каф. ПІ
Товстуха Іван                                                                                     Сокорчук І. П.












Харків 2024
2 РОЗРОБКА БАЗИ ДАНИХ ДЛЯ СЕРВЕРНОЇ ЧАСТИНИ ПРОГРАМНОЇ СИСТЕМИ ТА ПРИКЛАДНОГО ПРОГРАМНОГО ІНТЕРФЕЙСУ (API)

2.1	Мета роботи
     Розробити базу даних для серверної частини програмної системи та прикладного програмного інтерфейсу для програмної системи AquaSense.
2.2	Хід роботи
2.2.1	Опис інженерних рішень
     У процесі розробки програмної системи AquaSense було прийнято ряд інженерних рішень, спрямованих на створення надійної, масштабованої та зручної бази даних, серверної частини та прикладного програмного інтерфейсу (API). Основні рішення були продиктовані аналізом функціональних вимог системи та зосереджені на досягненні високої продуктивності, цілісності даних та ефективності взаємодії між компонентами.
     База даних AquaSense побудована на реляційній моделі даних із використанням MySQL. Такий вибір обумовлений перевагами цієї СУБД, серед яких масштабованість, висока надійність і підтримка транзакцій. Ця система дозволяє обробляти значні обсяги даних завдяки ефективним механізмам зберігання та забезпечує логічну цілісність даних через використання зовнішніх ключів і обмежень. Основу бази складають п'ять таблиць: Users, Aquariums, Sensors, Devices і Logs.
     Таблиця Users містить інформацію про користувачів системи, включаючи унікальний ідентифікатор, ім'я, електронну пошту та хешований пароль. Вона є основною для зв'язку з таблицею Aquariums, яка описує акваріуми, пов'язані з конкретними користувачами. 
   
     Таблиця Sensors забезпечує зберігання даних про сенсори, які вимірюють ключові параметри акваріуму, а таблиця Devices містить інформацію про пристрої, що використовуються для управління цими параметрами. Таблиця Logs реєструє всі події системи, включаючи зміни у стані пристроїв або сенсорів. 
     Зв'язки між таблицями забезпечують чітку організацію даних, зокрема:
- користувачі можуть володіти кількома акваріумами;
- один акваріум може мати декілька сенсорів і пристроїв;
- сенсори генерують записи у логах, що забезпечує історичне збереження даних.
     Для серверної частини було обрано платформу Node.js у поєднанні з фреймворком Express.js. Ці інструменти забезпечують високу продуктивність завдяки неблокуючій архітектурі та модульності. Express.js спрощує створення REST API, а велика екосистема Node.js забезпечує інтеграцію з іншими компонентами, такими як MQTT для обміну даними між сервером і IoT-пристроями.
     Реалізоване REST API дозволяє користувачам взаємодіяти із системою через чітко структуровані маршрути, забезпечуючи виконання CRUD-операцій для кожної сутності бази даних. Наприклад, маршрут /users використовується для отримання інформації про користувачів, тоді як /sensors дозволяє додавати нові сенсори або оновлювати їх дані. Авторизація користувачів реалізована через хешування паролів із використанням бібліотеки bcrypt, що гарантує безпеку персональних даних.
     Інтеграція з MQTT забезпечує миттєвий обмін даними між сервером та IoT-пристроями. IoT-пристрої передають показники сенсорів через MQTT, а сервер аналізує отримані дані та, у разі необхідності, надсилає команди для ввімкнення або вимкнення пристроїв. Цей механізм дозволяє системі підтримувати параметри акваріуму в межах заданих норм, які можуть бути налаштовані користувачами через REST API.
     Взаємодія між компонентами системи виглядає наступним чином: IoT-пристрої передають дані про параметри середовища до серверу. Сервер аналізує ці дані, зберігає їх у базу даних і, за потреби, надсилає команди пристроям. Логи подій записуються в базу даних, що дозволяє адміністраторам аналізувати історичні дані та приймати обґрунтовані рішення щодо налаштування системи.
     Прийняті рішення забезпечують масштабованість системи. У разі необхідності можна легко додавати нові сенсори, пристрої або навіть нових користувачів без суттєвих змін у базі даних чи архітектурі серверної частини. Завдяки використанню сучасних технологій і структурованого підходу до розробки, AquaSense є надійною, ефективною та зручною в експлуатації системою для автоматизації управління акваріумами.
2.2.2	Розробка UML діаграми прецедентів (Use Case Diagram)
     Система AquaSense призначена для моніторингу та управління параметрами акваріумів. Вона базується на використанні сенсорів, пристроїв IoT та серверної частини з базою даних. Основні інженерні рішення системи зосереджені на досягненні ефективності, зручності використання та масштабованості. Усі операції в системі базуються на взаємодії двох ключових акторів: Адміністратор і IoT-пристрій.
     Адміністратор виконує завдання, пов'язані з керуванням системою, а саме: авторизація, перегляд показників середовища (температура, рівень кисню, pH), управління пристроями (увімкнення/вимкнення), аналіз логів, налаштування діапазонів норм для сенсорів, а також додавання та видалення сенсорів і пристроїв. Адміністратор взаємодіє із системою через веб-інтерфейс або REST API, що надає доступ до всіх функцій системи, таких як налаштування параметрів чи отримання історичних даних.
     IoT-пристрій автономно виконує функції збору даних сенсорів, передає ці дані на сервер через MQTT-протокол і реагує на команди сервера, виконуючи відповідні дії. 
     Він є основним компонентом автоматизації, забезпечуючи зворотний зв'язок із системою. IoT-пристрій також відповідає за інформування сервера про стан пристроїв.
     Система реалізує кілька функціональних можливостей, які структуровані у вигляді прецедентів:
- моніторинг параметрів середовища: IoT-пристрій передає показники сенсорів, а адміністратор отримує доступ до цих даних через API або веб-інтерфейс;
- керування пристроями: у разі відхилення параметрів від норми сервер надсилає команди пристроям для корекції показників, а після стабілізації параметра пристрій вимикається;
- логування подій пристроїв: система записує всі події, пов'язані з пристроями, у базу даних, включаючи час активації та зміни параметрів;
- збереження історичних даних: дані від сенсорів зберігаються в базі даних, що дозволяє проводити аналіз і створювати звіти;
- налаштування діапазонів норм: адміністратор задає мінімальні та максимальні значення параметрів, які перевіряються системою;
- додавання та видалення пристроїв: адміністратор може додавати або видаляти пристрої через REST API або веб-інтерфейс. База даних автоматично оновлюється відповідно до цих змін;
- додавання та видалення сенсорів: система дозволяє інтегрувати нові сенсори або видаляти існуючі з акваріумів;
- авторизація користувачів: система перевіряє дані користувачів під час входу, використовуючи шифровані паролі для захисту;
- отримання даних сенсорів через MQTT: IoT-пристрій надсилає дані про стан середовища до сервера, де вони обробляються та зберігаються;
- відправка команд управління пристроями: сервер надсилає IoT-пристрою команди для ввімкнення чи вимкнення пристроїв;
- перегляд логів та історичних даних: адміністратор отримує доступ до журналів подій та історичних даних для проведення аналізу.
     Взаємодія між актором "Адміністратор" та системою побудована таким чином, щоб забезпечити максимальну функціональність із використанням інтуїтивного веб-інтерфейсу або REST API. Адміністратор має змогу здійснювати моніторинг, керувати пристроями та аналізувати дані в реальному часі.
     IoT-пристрій, у свою чергу, забезпечує збір даних і їхню передачу на сервер. Він також виконує команди сервера, пов'язані з управлінням пристроями, реагуючи на зміни параметрів середовища. Завдяки MQTT-протоколу ця взаємодія відбувається в режимі реального часу, забезпечуючи автоматизацію корекції параметрів.
     Алгоритми обробки даних сенсорів розроблені з урахуванням динаміки показників, що забезпечує їх корекцію навіть за умов різких коливань. Це підвищує ефективність пристроїв та запобігає тривалим відхиленням від норми. Використання MQTT-протоколу забезпечує мінімальну затримку передачі даних між IoT-пристроями та сервером, що особливо важливо для оперативної корекції параметрів. Це робить систему придатною для роботи в реальному часі. Адміністратор отримує можливість створювати звіти та аналізувати історичні дані, що дозволяє визначати довготривалі тренди та оптимізувати налаштування акваріумів. Це корисно для підтримки екосистеми в стабільному стані. Інтеграція інтуїтивного веб-інтерфейсу робить систему доступною навіть для користувачів без технічного досвіду, дозволяючи легко управляти акваріумами, аналізувати дані та налаштовувати параметри середовища.
     Система AquaSense демонструє комплексний підхід до управління параметрами акваріумів, інтегруючи автоматизацію IoT-пристроїв, гнучкість серверної частини та зручність для кінцевих користувачів. Усі її компоненти ефективно взаємодіють між собою, забезпечуючи стабільність і надійність роботи.
     

Рисунок 2.1 - UML діаграма прецедентів
2.2.3	Розробка ER-моделі даних (Entity-Relationship Model)
     Система AquaSense використовує реляційну базу даних, яка забезпечує зберігання, структурування та управління інформацією про користувачів, акваріуми, сенсори, пристрої та логи. Структура бази даних включає п'ять основних таблиць, кожна з яких виконує окрему функцію в межах системи.
     Таблиця Users зберігає дані про користувачів системи, включаючи їх унікальні ідентифікатори, імена, електронні адреси, хешовані паролі та час створення облікового запису. Ця таблиця є основою для зв'язку з іншими елементами бази даних, зокрема з таблицею Aquariums, яка містить інформацію про акваріуми, прив'язані до конкретного користувача. Поля таблиці Aquariums включають унікальні ідентифікатори акваріумів, ідентифікатор власника, назву, ємність та час створення запису.
     Таблиця Sensors забезпечує зберігання даних про сенсори, які встановлені в акваріумах. Кожен сенсор має унікальний ідентифікатор, посилання на відповідний акваріум, тип (наприклад, температура, рівень кисню чи pH), поточне значення та час створення запису. Ці сенсори взаємодіють із таблицею Logs, яка записує всі події, пов'язані з показниками сенсорів та змінами параметрів акваріума. Кожен запис у таблиці Logs включає ідентифікатор сенсора, повідомлення про подію та час запису.
     Управління параметрами акваріумів здійснюється за допомогою таблиці Devices, яка містить інформацію про пристрої, що керують параметрами акваріуму. Ці пристрої мають унікальні ідентифікатори, прив'язку до конкретного акваріума, назви, поточний стан (увімкнено або вимкнено) та час створення запису.
     Відношення між таблицями забезпечують логічну цілісність даних. Користувачі можуть володіти декількома акваріумами, кожен з яких може мати кілька сенсорів та пристроїв. Сенсори, у свою чергу, генерують записи в логах, що дозволяє відстежувати зміни параметрів середовища або стану пристроїв. Така структура бази даних є масштабованою та дозволяє легко інтегрувати нові сенсори, пристрої або користувачів, підтримуючи чіткий зв'язок між усіма елементами системи.
     

Рисунок 2.2 - ER діаграма даних
2.2.4	Створення діаграми структури БД
     Система AquaSense побудована на реляційній базі даних, що забезпечує ефективне зберігання та обробку даних, пов'язаних із користувачами, акваріумами, сенсорами, пристроями та подіями. Ключовим елементом структури є таблиця Users, яка містить інформацію про користувачів, включаючи їхні унікальні ідентифікатори, імена, електронні адреси, хешовані паролі та час створення облікового запису. Ця таблиця є основою для зв'язку з іншими таблицями системи.
     Таблиця Aquariums забезпечує зберігання даних про акваріуми, які належать користувачам. Кожен запис пов'язаний із конкретним користувачем за допомогою зовнішнього ключа, а також містить дані про назву акваріума, його ємність та час створення. Таблиця має зв'язок з таблицями Sensors і Devices, які деталізують технічні аспекти моніторингу та управління параметрами акваріума.
     Sensors відіграють ключову роль у системі, оскільки вони зберігають дані про вимірювані параметри середовища, такі як температура, рівень кисню або pH. Кожен сенсор пов'язаний із певним акваріумом, а його записи включають тип сенсора, поточне значення та час створення. З цими даними пов'язана таблиця Logs, яка містить історію змін параметрів сенсорів та інших подій, пов'язаних із їхньою роботою.
     Таблиця Devices відповідає за управління пристроями, які регулюють параметри середовища акваріума. До таких пристроїв належать, наприклад, термостати, аератори або контролери pH. У таблиці зберігаються дані про назву пристрою, його стан (увімкнено чи вимкнено) та час створення. Вона має зв'язок із таблицею Aquariums, що забезпечує логічну прив'язку кожного пристрою до конкретного акваріума.
     Історичні дані та журнали подій зберігаються в таблиці Logs, яка містить записи про стан сенсорів та пристроїв. Кожен запис включає повідомлення про подію, час створення та зв'язок із відповідним сенсором через зовнішній ключ. Ця таблиця забезпечує простоту аналізу та можливість відстеження змін у системі.
     Зв'язки між таблицями побудовані на принципі "один-до-багатьох". Один користувач може мати кілька акваріумів, кожен із яких може містити кілька сенсорів та пристроїв. Сенсори, у свою чергу, можуть генерувати численні записи в логах. Така структура забезпечує логічну цілісність і дозволяє ефективно організувати дані.
     Система має низку переваг. Масштабованість дозволяє легко інтегрувати нові сенсори, пристрої або додавати нових користувачів. 
     Чіткість зв'язків між таблицями забезпечує цілісність даних і мінімізує ризики втрати інформації. Простота аналізу, досягнута за рахунок структурування даних, дозволяє зручно відстежувати зміни в системі. Крім того, система є безпечною завдяки впровадженню обмежень, таких як унікальність електронних адрес користувачів.
     Ця структура бази даних забезпечує основу для функціонування серверної частини AquaSense, а також ефективну інтеграцію з API та IoT-пристроями. Завдяки їй система є надійною, масштабованою та легкою в обслуговуванні.


Рисунок 2.3 - діаграма структури БД
2.2.5	Специфікація розробленого REST API
Метод
Маршрут
Опис
POST
/users/register
Реєстрація нового користувача
POST
/users/login
Авторизація користувача
GET
/users
Отримання списку всіх користувачів
GET
/users/{id}
Отримання даних про користувача за його ID
PUT
/users/{id}
Оновлення інформації про користувача
DELETE
/users/{id}
Видалення користувача за його ID
POST
/aquariums
Додавання нового акваріума
GET
/aquariums
Отримання списку всіх акваріумів
GET
/aquariums/user/{userId}
Отримання списку акваріумів для конкретного користувача
GET
/aquariums/{id}
Отримання інформації про акваріум за його ID
PUT
/aquariums/{id}
Оновлення інформації про акваріум
DELETE
/aquariums/{id}
Видалення акваріума за його ID
POST
/devices
Додавання нового пристрою
GET
/devices
Отримання списку всіх пристроїв
GET
/devices/aquarium/{aquariumId}
Отримання списку пристроїв для конкретного акваріума
GET
/devices/{id}
Отримання інформації про пристрій за його ID
PUT
/devices/{id}
Оновлення інформації про пристрій
DELETE
/devices/{id}
Видалення пристрою за його ID
POST
/sensors
Додавання нового сенсора
GET
/sensors
Отримання списку всіх сенсорів
GET
/sensors/aquarium/{aquariumId}
Отримання списку сенсорів для конкретного акваріума
GET
/sensors/{id}
Отримання інформації про сенсор за його ID
PUT
/sensors/{id}
Оновлення інформації про сенсор
DELETE
/sensors/{id}
Видалення сенсора за його ID
POST
/logs
Додавання нового логу
GET
/logs
Отримання списку всіх логів
GET
/logs/sensor/{sensorId}
Отримання списку логів для конкретного сенсора
GET
/logs/{id}
Отримання конкретного логу за його ID
DELETE
/logs/{id}
Видалення конкретного логу
DELETE
/logs/sensor/{sensorId}
Видалення всіх логів для конкретного сенсора

2.3	Висновки
     У ході лабораторної роботи була розроблена база даних для серверної частини програмної системи управління океанаріумом. Створена структура бази даних забезпечує ефективне збереження та обробку інформації про користувачів, акваріуми, сенсори, пристрої та журнали подій. 
     Також реалізовано прикладний програмний інтерфейс, який дозволяє взаємодіяти з базою даних через REST API.
     ДОДАТОК А
     Скрипт на створення таблиць у БД AquaSense

     1. CREATE TABLE Users (
     2.     id INT AUTO_INCREMENT PRIMARY KEY,
     3.     username VARCHAR(50) NOT NULL,
     4.     email VARCHAR(100) NOT NULL UNIQUE,
     5.     password VARCHAR(255) NOT NULL,
     6.     created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
     7. );
     8. 
     9. CREATE TABLE Aquariums (
     10.     id INT AUTO_INCREMENT PRIMARY KEY,
     11.     user_id INT NOT NULL,
     12.     name VARCHAR(100) NOT NULL,
     13.     specification VARCHAR(100),
     14.     created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
     15.     FOREIGN KEY (user_id) REFERENCES Users(id) ON DELETE CASCADE
     16. );
     17. 
     18. CREATE TABLE Sensors (
     19.     id INT AUTO_INCREMENT PRIMARY KEY,
     20.     aquarium_id INT NOT NULL,
     21.     type VARCHAR(255) NOT NULL,
     22.     value DECIMAL(10, 2) NOT NULL,
     23.     created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
     24.     FOREIGN KEY (aquarium_id) REFERENCES Aquariums(id) ON DELETE CASCADE
     25. );
     26. 
     27. CREATE TABLE Logs (
     28.     id INT AUTO_INCREMENT PRIMARY KEY,
     29.     sensor_id INT NOT NULL,
     30.     message VARCHAR(255),
     31.     logged_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
     32.     FOREIGN KEY (sensor_id) REFERENCES Sensors(id) ON DELETE CASCADE
     33. );
     34. 
     35. CREATE TABLE Devices (
     36.     id INT AUTO_INCREMENT PRIMARY KEY,
     37.     aquarium_id INT NOT NULL,
     38.     name VARCHAR(100) NOT NULL,
     39.     status ENUM('on', 'off') DEFAULT 'off',
     40.     created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
     41.     FOREIGN KEY (aquarium_id) REFERENCES Aquariums(id) ON DELETE CASCADE
     42. );





     
     ДОДАТОК Б
     Код для взаємодії серверної частини з БД

     1. const express = require('express');
     2. const swaggerUi = require('swagger-ui-express');
     3. const swaggerDocument = require('./swagger.json');
     4. const db = require('./src/config/db');
     5. const mqtt = require('mqtt'); // MQTT клієнт
     6. 
     7. const app = express();
     8. const PORT = 3000;
     9. 
     10. // Middleware
     11. app.use(express.json());
     12. 
     13. // Swagger UI
     14. app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerDocument));
     15. 
     16. // Підключення маршрутів
     17. const userRoutes = require('./src/routes/users');
     18. const aquariumRoutes = require('./src/routes/aquariums');
     19. const deviceRoutes = require('./src/routes/devices');
     20. const sensorRoutes = require('./src/routes/sensors');
     21. const logRoutes = require('./src/routes/logs');
     22. 
     23. app.use('/users', userRoutes);
     24. app.use('/aquariums', aquariumRoutes);
     25. app.use('/devices', deviceRoutes);
     26. app.use('/sensors', sensorRoutes);
     27. app.use('/logs', logRoutes);
     28. 
     29. // MQTT брокер
     30. const mqttBroker = 'mqtt://test.mosquitto.org';
     31. const mqttClient = mqtt.connect(mqttBroker);
     32. 
     33. // Теми MQTT
     34. const topics = [
     35.   { topic: 'aquarium/sensor/temperature', sensorType: 'temperature', deviceName: 'thermostat', range: [22, 28] },
     36.   { topic: 'aquarium/sensor/oxygen', sensorType: 'oxygen', deviceName: 'aerator', range: [4, 10] },
     37.   { topic: 'aquarium/sensor/ph', sensorType: 'ph', deviceName: 'phController', range: [5, 8] },
     38. ];
     39. 
     40. // Поточний сенсор
     41. let currentIndex = 0;
     42. let processing = false;
     43. 
     44. // Підключення до MQTT
     45. mqttClient.on('connect', () => {
     46.   console.log('Connected to MQTT broker');
     47.   mqttClient.subscribe(topics.map(t => t.topic), (err) => {
     48.     if (err) {
     49.       console.error('Error subscribing to topics:', err.message);
     50.     } else {
     51.       console.log('Subscribed to topics:', topics.map(t => t.topic).join(', '));
     52.     }
     53.   });
     54. });
     55. 
     56. // Тестовий маршрут
     57. app.get('/', (req, res) => {
     58.     res.send('Welcome to AquaSense API');
     59. });
     60. 
     61. // Запуск сервера
     62. app.listen(PORT, () => {
     63.     console.log(`Server is running on http://localhost:${PORT}`);
     64.     console.log(`Swagger UI is available at http://localhost:${PORT}/api-docs`);
     65. });





     
     ДОДАТОК В
     Код взаємодії серверної частини з клієнтами
     
	1. const express = require("express");
     2. const router = express.Router();
     3. const db = require("../config/db");
     4. const bcrypt = require("bcrypt");
     5. 
     6. // Реєстрація користувача
     7. router.post("/register", async (req, res) => {
     8.   const { username, email, password } = req.body;
     9.   const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
     10. 
     11.   if (!emailRegex.test(email)) {
     12.     return res
     13.       .status(400)
     14.       .json({ success: false, message: "Invalid email format" });
     15.   }
     16. 
     17.   try {
     18.     const [user] = await db.query("SELECT * FROM Users WHERE email = ?", [
     19.       email,
     20.     ]);
     21.     if (user.length > 0) {
     22.       return res
     23.         .status(400)
     24.         .json({ success: false, message: "User already exists" });
     25.     }
     26. 
     27.     const hashedPassword = await bcrypt.hash(password, 10);
     28. 
     29.     const [result] = await db.query(
     30.       "INSERT INTO Users (username, email, password) VALUES (?, ?, ?)",
     31.       [username, email, hashedPassword]
     32.     );
     33. 
     34.     res.status(201).json({
     35.       success: true,
     36.       message: "User registered successfully",
     37.       userId: result.insertId,
     38.     });
     39.   } catch (error) {
     40.     console.error("Error during user registration:", error);
     41.     res.status(500).json({ success: false, error: error.message });
     42.   }
     43. });
     44. 
     45. // Авторизація користувача
     46. router.post("/login", async (req, res) => {
     47.   const { email, password } = req.body;
     48.   const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
     49. 
     50.   if (!emailRegex.test(email)) {
     51.     return res
     52.       .status(400)
     53.       .json({ success: false, message: "Invalid email format" });
     54.   }
     55.   try {
     56.     const [user] = await db.query("SELECT * FROM Users WHERE email = ?", [
     57.       email,
     58.     ]);
     59.     if (user.length === 0) {
     60.       return res
     61.         .status(404)
     62.         .json({ success: false, message: "User not found" });
     63.     }
     64. 
     65.     const isPasswordValid = await bcrypt.compare(password, user[0].password);
     66.     if (!isPasswordValid) {
     67.       return res
     68.         .status(401)
     69.         .json({ success: false, message: "Invalid credentials" });
     70.     }
     71. 
     72.     res.json({
     73.       success: true,
     74.       message: "Login successful",
     75.       user: { id: user[0].id, username: user[0].username },
     76.     });
     77.   } catch (error) {
     78.     console.error("Error during user login:", error);
     79.     res.status(500).json({ success: false, error: error.message });
     80.   }
     81. });
     82. 
     83. // Отримання списку всіх користувачів
     84. router.get("/", async (req, res) => {
     85.   try {
     86.     const [users] = await db.query(
     87.       "SELECT id, username, email, created_at FROM Users"
     88.     );
     89.     res.json({ success: true, users });
     90.   } catch (error) {
     91.     console.error("Error fetching users:", error);
     92.     res.status(500).json({ success: false, error: error.message });
     93.   }
     94. });
     95. 
     96. // Отримання користувача за ID
     97. router.get("/:id", async (req, res) => {
     98.   const userId = req.params.id;
     99. 
     100.   try {
     101.     const [user] = await db.query(
     102.       "SELECT id, username, email, created_at FROM Users WHERE id = ?",
     103.       [userId]
     104.     );
     105.     if (user.length === 0) {
     106.       return res
     107.         .status(404)
     108.         .json({ success: false, message: "User not found" });
     109.     }
     110.     res.json({ success: true, user: user[0] });
     111.   } catch (error) {
     112.     console.error("Error fetching user by ID:", error);
     113.     res.status(500).json({ success: false, error: error.message });
     114.   }
     115. });
     116. 
     117. // Оновлення даних користувача
     118. router.put("/:id", async (req, res) => {
     119.   const userId = req.params.id;
     120.   const { username, email } = req.body;
     121.   const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
     122. 
     123.   if (!emailRegex.test(email)) {
     124.     return res
     125.       .status(400)
     126.       .json({ success: false, message: "Invalid email format" });
     127.   }
     128.   try {
     129.     // Перевіряємо, чи користувач існує
     130.     const [user] = await db.query("SELECT * FROM Users WHERE id = ?", [userId]);
     131.     if (user.length === 0) {
     132.       return res
     133.         .status(404)
     134.         .json({ success: false, message: "User not found" });
     135.     }
     136. 
     137.     // Оновлюємо дані користувача
     138.     const [result] = await db.query(
     139.       "UPDATE Users SET username = ?, email = ? WHERE id = ?",
     140.       [username, email, userId]
     141.     );
     142. 
     143.     res.json({
     144.       success: true,
     145.       message: `User with ID ${userId} successfully updated`,
     146.     });
     147.   } catch (error) {
     148.     console.error("Error updating user:", error);
     149.     res.status(500).json({ success: false, error: error.message });
     150.   }
     151. });
     152. 
     153. // Видалення користувача
     154. router.delete("/:id", async (req, res) => {
     155.   const userId = req.params.id;
     156. 
     157.   try {
     158.     const [user] = await db.query("SELECT * FROM Users WHERE id = ?", [userId]);
     159.     if (user.length === 0) {
     160.       return res
     161.         .status(404)
     162.         .json({ success: false, message: "User not found" });
     163.     }
     164. 
     165.     await db.query("DELETE FROM Users WHERE id = ?", [userId]);
     166.     res.json({
     167.       success: true,
     168.       message: `User with ID ${userId} has been deleted`,
     169.     });
     170.   } catch (error) {
     171.     console.error("Error deleting user:", error);
     172.     res.status(500).json({ success: false, error: error.message });
     173.   }
     174. });
     175. 
     176. module.exports = router;


Посилання на відеозапис: 
