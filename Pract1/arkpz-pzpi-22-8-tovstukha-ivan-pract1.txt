Міністерство освіти і науки України
Харківський національний університет радіоелектроніки



Кафедра програмної інженерії





Звіт
з практичної роботи №1
з дисципліни  «Аналіз та рефакторінг коду»
на тему «Правила оформлення програмного коду
на мові програмування Go»





Виконав:						                                    Перевірив:
Ст. гр. ПЗПІ-22-8                                  	                                    ст. викл. Сокорчук І. П.
Товстуха І. К. 





Харків 2024



1.1 Мета роботи

Дослідити правила оформлення коду на Go, розробити рекомендації для написання чистого коду та оцінити їхній вплив на якість розробки. 
Результатом роботи буде набір правил і, можливо, інструментів для автоматизації перевірки коду на відповідність стандартам.

1.2 Хід роботи

	1.2.1 Посилання на YouTube
	URL: 

	1.2.2 Особливості мови Go

Go, або Golang, — це сучасна мова програмування, розроблена компанією Google у 2007 році, офіційно випущена у 2012 році. 
Вона створена для простоти, продуктивності та масштабованості, ставлячи акцент на ефективній роботі в багатопотокових середовищах. 
Go поєднує простоту синтаксису мов на кшталт Python із продуктивністю й можливостями низькорівневих мов, як-от C. 
Серед ключових особливостей мови — вбудована підтримка конкурентності через горутини та канали, що дозволяють легко розробляти багатопоточні додатки. 
Go також пропонує потужну систему управління пам'яттю з автоматичним збирачем сміття, яка мінімізує складнощі ручного керування ресурсами. 
Компактна стандартна бібліотека надає широкий спектр функціональності для мережевого програмування, роботи з файлами, обробки даних тощо. 
Завдяки строгій типізації, простоті та підтримці модульності, Go став популярним вибором для створення хмарних сервісів, мікросервісів і високонавантажених систем. 


1.3 Основні рекомендації щодо оформлення програмного коду на мові Go

  1.3.1 Називайте інтерфейси відповідно до їхньої поведінки

У Go існує правило щодо іменування інтерфейсів, особливо для однометодних типів. Згідно з цим правилом, інтерфейси часто мають ім'я, 
яке складається з назви методу плюс суфікс -er (або інша модифікація, що позначає виконавця дії).Такі імена інтерфейсів створюються з метою 
чіткого позначення їх призначення та зручності використання. Це дозволяє розробникам Go розуміти, що конкретний тип може виконувати певну 
дію без необхідності детально вивчати код.

1: // Поганий приклад
2: type ToString interface {
3: 	String() string
4: }
5: 
6: 
7: // Гарний приклад
8: type Stringer interface {
9: 	String() string
10: }

Розглянемо поганий приклад коду:
У цьому прикладі інтерфейс називається ToString. Це порушує домовленість, оскільки як я казав раніше назва інтерфейсу має позначати виконавця дії.

Розглянемо хороший приклад коду:
У цьому прикладі інтерфейс називається Stringer, що є гарним ім'ям для інтерфейсу, який вимагає реалізації методу String(). 
Це робить код зрозумілим для інших розробників і відповідає ідіоматичним практикам Go.

Висновок:
Для однометодних інтерфейсів у Go використовується назва методу плюс суфікс -er або інший подібний суфікс, що вказує на тип, який реалізує цей метод.
Це дозволяє зробити код Go більш інтуїтивно зрозумілим та відповідним стандартам мови.

  1.3.2 Уникайте префіксу Get у геттерах

У мові Go немає вбудованої підтримки геттерів та сеттерів, як це є в деяких інших мовах. 
У Go, доступ до полів структури зазвичай відбувається безпосередньо. Однак, якщо потрібно забезпечити контроль доступу до полів 
або виконати додаткову логіку під час читання або запису значення, можна вручну створити геттери та сеттери. 

1: // Поганий приклад
2: type Person struct {
3: 	Name string
4: 	Age  int
5: }
6: 
7: func (p *Person) GetName() string {
8: 	return p.Name
9: }
10: 
11: func (p *Person) GetAge() int {
12: 	return p.Age
13: }
14: 
15: 
16: // Гарний приклад
17: type Person struct {
18: 	Name string
19: 	Age  int
20: }
21: 
22: func (p *Person) Name() string {
23: 	return p.Name
24: }
25: 
26: func (p *Person) Age() int {
27: 	return p.Age
28: }

Розглянемо поганий приклад коду:
У цьому прикладі використовуються методи з префіксом Get, щоб повернути значення полів структури. 
Це не є ідіоматичним для Go, оскільки в Go зазвичай не використовують такий підхід для доступу до полів.

Розглянемо хороший приклад коду:
Тут ми використовуємо імена методів без префікса Get, що є більш природним і зручним для Go. 
Зазвичай у Go не потрібно додавати "Get" перед ім'ям методу для доступу до значення, і це робить код менш громіздким.

Висновок:
У Go використання префікса Get в назвах геттерів не є вірним. 
Натомість назви методів мають бути лаконічними і вказувати на суть даних або дій, пов’язаних із полем структури.

  1.3.3 Завжди обробляйте помилки

У Go повертання помилок є стандартним способом обробки виключень та помилок. Мова Go не підтримує механізм обробки винятків, 
натомість Go використовує значення типу error, яке є інтерфейсним типом і призначене для позначення помилок у функціях.
За домовленістю, якщо функція може згенерувати помилку, останнім параметром результату цієї функції буде тип error. 
Це дозволяє викликати функцію та перевіряти наявність помилки в кінці, роблячи код зручним для читання та підтримки.

1: // Поганий приклад
2: func divide(a, b int) (result int, err error) {
3: 	if b == 0 {
4: 			err = errors.New("division by zero")
5: 			return 0, err
6: 	}
7: 	result = a / b
8: 	return result, nil
9: }
10: 
11: 
12: // Гарний приклад
13: func divide(a, b int) (int, error) {
14: 	if b == 0 {
15: 			return 0, errors.New("division by zero")
16: 	}
17: 	return a / b, nil
18: }

Розглянемо поганий приклад коду:
У цьому прикладі функція  не дотримується правильного стилю і може бути важчою для розуміння в деяких контекстах через заплутані імена параметрів.

Розглянемо хороший приклад коду:
У цьому прикладі функція divide повертає два значення: результат ділення та помилку. Параметри функції визначені чітко, і тип error є останнім параметром, 
що відповідає канонічному стилю Go. Якщо ділення на нуль відбувається, функція повертає 0 як результат і створену помилку.

Висновок:
Для позначення помилок використовується тип error, який є стандартним інтерфейсом.Якщо функція може згенерувати помилку, повернення помилки має бути останнім параметром.
Цей підхід забезпечує ясність у функціях і полегшує обробку помилок, оскільки дозволяє чітко визначити місце для перевірки помилки в коді.

  1.3.4 Не використовуйте panic для звичайної обробки помилок

1: // Поганий приклад
2: package main
3: 
4: import (
5: 	"fmt"
6: )
7: 
8: func divide(a, b int) int {
9: 	if b == 0 {
10: 		panic("division by zero")
11: 	}
12: 	return a / b
13: }
14: 
15: func main() {
16: 	result := divide(10, 0)
17: 	fmt.Println(result)
18: }
19: 
20: 
21: // Гарний приклад
22: package main
23: 
24: import (
25: 	"errors"
26: 	"fmt"
27: )
28: 
29: func divide(a, b int) (int, error) {
30: 	if b == 0 {
31: 		return 0, errors.New("division by zero")
32: 	}
33: 	return a / b, nil
34: }
35: 
36: func main() {
37: 	result, err := divide(10, 0)
38: 	if err != nil {
39: 		fmt.Println("Error:", err)
40: 		return
41: 	}
42: 	fmt.Println("Result:", result)
43: }

Розглянемо поганий приклад коду:
У цьому прикладі використано panic для обробки звичайної помилки (ділення на нуль), що призводить до припинення роботи програми. 
Це не рекомендується в Go, оскільки можна обробити таку ситуацію без припинення програми.

Розглянемо хороший приклад коду:
У цьому прикладі повертаємо помилку як останнє значення з функції, якщо операція ділення неможлива через ділення на нуль. 
У функції main ми перевіряємо наявність помилки перед тим, як працювати з результатом. Це дає змогу програмі продовжити 
виконання навіть при наявності помилки, а не завершувати її аварійно.

Висновок:
Не використовуйте panic для звичайних помилок. panic має використовуватися лише в ситуаціях, коли програма не може продовжити виконання через серйозні помилки.
Використовуйте error для обробки звичайних помилок. Функції повинні повертати помилки як останні значення, щоб їх можна було обробляти без припинення програми.
Обробляйте помилки у основному потоці програми, перевіряючи їх перед тим, як працювати з результатами функцій, щоб програма залишалася стабільною і надійною.
Цей підхід допомагає зберігати програму стабільною та відмовостійкою, надаючи можливість обробляти помилки без необхідності її аварійного завершення.

  1.3.5 Будьте обережні при копіюванні структур

У Go копіювання об'єктів може призвести до неочікуваних помилок, особливо якщо об'єкти є синхронізацією, як, наприклад, Mutex або RWMutex. 
Це стосується ситуацій, коли об'єкт синхронізації копіюється замість того, щоб передаватися за посиланням.
Mutex (і подібні об'єкти синхронізації) повинні бути передані як посилання, оскільки їх копіювання може призвести до неочікуваної поведінки, 
такої як нескінченні блокування або неправильна синхронізація, через те, що кожен екземпляр Mutex має свій власний стан блокування.
Копіюючи об'єкти, що містять стан, ви створюєте окремі копії, що означає, що один з Mutex може бути заблокований, а інший залишиться незаблокованим, 
навіть якщо вони мають відносини у програмі.

1: // Поганий приклад
2: package main
3: 
4: import (
5: 	"fmt"
6: 	"sync"
7: )
8: 
9: type MyStruct struct {
10: 	mu sync.Mutex
11: }
12: 
13: func main() {
14: 	original := MyStruct{}
15: 	copy := original
16: 
17: 	copy.mu.Lock()
18: 	fmt.Println("Lock acquired.")
19: }
20: 
21: 
22: // Гарний приклад
23: package main
24: 
25: import (
26: 	"fmt"
27: 	"sync"
28: )
29: 
30: type MyStruct struct {
31: 	mu sync.Mutex
32: }
33: 
34: func main() {
35: 	original := &MyStruct{}
36: 
37: 	original.mu.Lock()
38: 	defer original.mu.Unlock()
39: 
40: 	fmt.Println("Lock acquired and released.")
41: }

Розглянемо поганий приклад коду:
У цьому прикладі ми створюємо структуру MyStruct, що містить sync.Mutex (mu). Копіюємо цю структуру в іншу змінну copy. 
Це призводить до проблеми, оскільки копія структури має свою власну копію mu, яка є незалежною від оригіналу. 
Це може призвести до помилок синхронізації, таких як двічі заблокований mutex.

Розглянемо хороший приклад коду:
У цьому коді ми створюємо вказівник на MyStruct (тобто передаємо його за посиланням). Таким чином, весь стан структури (включаючи Mutex) 
передається без копіювання, і ми можемо правильно синхронізувати доступ.

Висновок:
Не копіюйте об'єкти синхронізації, такі як sync.Mutex або sync.RWMutex, оскільки це може призвести до непередбачуваної поведінки.
Передавайте об'єкти синхронізації за посиланням (через вказівники), щоб уникнути проблем з синхронізацією.
Це правило гарантує, що ваше використання об'єктів синхронізації залишатиметься безпечним і передбачуваним.

  1.3.6 Експортуйте лише необхідні інтерфейси

У Go інтерфейси грають важливу роль у забезпеченні абстракції та гнучкості. Однак для того, щоб правильно використовувати інтерфейси, 
потрібно дотримуватися кількох важливих практик, які допомагають зробити код більш зрозумілим, масштабованим і легко тестованим.

1: // Поганий приклад
2: package main
3: 
4: import (
5: 	"fmt"
6: )
7: 
8: type PaymentProcessor interface {
9: 	ProcessPayment(amount float64)
10: }
11: 
12: type CreditCardPayment struct{}
13: 
14: func (c *CreditCardPayment) ProcessPayment(amount float64) {
15: 	fmt.Println("Processing payment of", amount)
16: }
17: 
18: type PayPalPayment struct{}
19: 
20: func (p *PayPalPayment) ProcessPayment(amount float64) {
21: 	fmt.Println("Processing PayPal payment of", amount)
22: }
23: 
24: type MyServer struct {
25: 	paymentProcessor PaymentProcessor
26: }
27: 
28: func (s *MyServer) StartServer() {
29: 	s.paymentProcessor.ProcessPayment(100.0)
30: }
31: 
32: func main() {
33: 	server := &MyServer{}
34: 	server.StartServer()
35: }
36: 
37: 
38: // Гарний приклад
39: package main
40: 
41: import (
42: 	"fmt"
43: )
44: 
45: type CreditCardPayment struct{}
46: 
47: func (c *CreditCardPayment) ProcessPayment(amount float64) {
48: 	fmt.Println("Processing payment of", amount)
49: }
50: 
51: type MyServer struct {
52: 	paymentProcessor *CreditCardPayment
53: }
54: 
55: func (s *MyServer) StartServer() {
56: 	s.paymentProcessor.ProcessPayment(100.0)
57: }
58: 
59: func main() {
60: 	server := &MyServer{paymentProcessor: &CreditCardPayment{}}
61: 	server.StartServer()
62: }

Розглянемо поганий приклад коду:
У цьому коді інтерфейс PaymentProcessor визначений і використовується в сервері, але насправді цей інтерфейс не має сенсу у даному контексті, 
оскільки сервер обробляє лише один тип платежу PayPal. Тому визначення інтерфейсу без реальної потреби (як у цьому випадку) є поганою практикою, 
оскільки не дає гнучкості і додає зайвий рівень абстракції.

Розглянемо хороший приклад коду:
У цьому коді ми більше не використовуємо інтерфейс для обробки платежів. Замість цього використовуємо конкретний тип CreditCardPayment, 
що робить код простішим і зрозумілішим, оскільки немає зайвих абстракцій. Якщо в майбутньому потрібно буде додати інші способи обробки платежів, 
можна просто додати нові типи, що реалізують відповідні методи, без необхідності визначати додаткові інтерфейси.

Висновок:
Інтерфейси повинні належати пакету, що використовує їх, а не пакету, що реалізує типи. Не визначайте інтерфейси без реальної потреби, щоб уникнути 
непотрібних абстракцій. Не експортуйте непотрібні інтерфейси з пакета, якщо вони не будуть використовуватися зовнішніми користувачами. 
Дотримання цих практик дозволяє зберегти код чистим, простим для тестування та зрозумілим для інших розробників.

  1.3.7 Використовуйте Must функції лише для критичної ініціалізації

У Go існує угода про найменування для функцій, які повинні викликатися під час налаштування програми, і які призводять до зупинки програми, якщо виникає помилка. 
Такі функції зазвичай називаються Must. Це необхідні функції, які припускають, що їх виклик може призвести до фатальної помилки, і вони повинні бути використані 
лише на ранньому етапі ініціалізації програми, коли відсутність необхідних ресурсів або конфігурацій буде серйозною помилкою.

1: // Поганий приклад
2: package main
3: 
4: import (
5: 	"fmt"
6: 	"os"
7: )
8: 
9: func readConfigFile() string {
10: 	file, err := os.Open("config.yaml")
11: 	if err != nil {
12: 		panic("Failed to open config file")
13: 	}
14: 	defer file.Close()
15: 
16: 	var config string
17: 	_, err = fmt.Fscanf(file, "%s", &config)
18: 	if err != nil {
19: 		panic("Failed to read config file")
20: 	}
21: 
22: 	return config
23: }
24: 
25: func main() {
26: 	config := readConfigFile()
27: 	fmt.Println("Config:", config)
28: }
29: 
30: 
31: // Гарний приклад
32: package main
33: 
34: import (
35: 	"fmt"
36: 	"os"
37: )
38: 
39: func mustReadConfigFile() string {
40: 	file, err := os.Open("config.yaml")
41: 	if err != nil {
42: 		panic(fmt.Sprintf("Failed to open config file: %v", err))
43: 	}
44: 	defer file.Close()
45: 
46: 	var config string
47: 	_, err = fmt.Fscanf(file, "%s", &config)
48: 	if err != nil {
49: 		panic(fmt.Sprintf("Failed to read config file: %v", err))
50: 	}
51: 
52: 	return config
53: }
54: 
55: func main() {
56: 	config := mustReadConfigFile()
57: 	fmt.Println("Config:", config)
58: }

Розглянемо поганий приклад коду:
У цьому прикладі функція readConfigFile використовує panic для зупинки програми, якщо файл не можна відкрити або прочитати. Це є надмірним, 
оскільки в більшості випадків ми можемо просто обробити цю помилку, наприклад, вивести повідомлення про помилку та дозволити програмі продовжити роботу.

Розглянемо хороший приклад коду:
У цьому прикладі функція mustReadConfigFile має назву, що відповідає угоді MustXYZ, оскільки вона викликається тільки на самому початку, 
щоб налаштувати потрібні ресурси. Якщо відбувається помилка на етапі відкриття або читання конфігураційного файлу, програма негайно зупиняється, 
оскільки це критична помилка, яку необхідно виправити для подальшої роботи програми.

Висновок:
Must-функції використовуються для критичних налаштувань або перевірок, які не можуть бути відкладені і, у разі помилки,  а повинні призвести до зупинки програми.
Не використовуйте Must-функції для звичайної обробки помилок, таких як некоректні дані від користувача або проблеми під час обробки бізнес-логіки. 
Для таких ситуацій краще використовувати звичайну обробку помилок з типом error.

  1.3.8 Завжди закривайте ресурси за допомогою defer

У Go важливо правильно звільняти ресурси, такі як файли, мережеві з'єднання, або локи, після того, як вони більше не потрібні. 
defer є потужним інструментом для забезпечення правильного закриття цих ресурсів. За допомогою defer можна гарантувати, що необхідні дії будуть 
виконані при виході з функції, незалежно від того, чи була функція виконана успішно чи сталася помилка.

1: // Поганий приклад
2: func readFile(filePath string) (string, error) {
3: 	file, err := os.Open(filePath)
4: 	if err != nil {
5: 			return "", err
6: 	}
7: 	
8: 	contents, err := ioutil.ReadAll(file)
9: 	file.Close()
10: 	if err != nil {
11: 			return "", err
12: 	}
13: 	
14: 	return string(contents), nil
15: }
16: 
17: 
18: // Гарний приклад
19: func readFile(filePath string) (string, error) {
20: 	file, err := os.Open(filePath)
21: 	if err != nil {
22: 			return "", err
23: 	}
24: 	
25: 	defer file.Close()
26: 	
27: 	contents, err := ioutil.ReadAll(file)
28: 	if err != nil {
29: 			return "", err
30: 	}
31: 	
32: 	return string(contents), nil
33: }

Розглянемо поганий приклад коду:
У цьому прикладі є проблема — ми вручну викликаємо закриття файлу після завершення обробки. Це може бути помилкою, 
якщо функція поверне помилку перед викликом file.Close(), або якщо файл залишиться відкритим при великих розмірах коду.

Розглянемо хороший приклад коду:
Тут defer file.Close() оголошено одразу після відкриття файлу, що гарантує його закриття при завершенні функції, незалежно від того, 
чи сталася помилка під час читання файлу чи ні.

Висновок:
Завжди використовуйте defer для закриття ресурсів — це робить код більш безпечним і надає гарантії, що ресурси будуть правильно звільнені, 
навіть у випадку помилок або раннього виходу з функції. Не відкладайте операції, які є критичними для успішного завершення функції. 
Використовуйте defer для звільнення не критичних ресурсів після виконання основної роботи функції. Правильне використання defer допомагає 
підтримувати чистоту коду та забезпечує надійне управління ресурсами. Це особливо важливо для забезпечення коректної роботи програм, 
де ресурси, такі як файли чи мережеві з'єднання, повинні бути закриті після використання.


Загальні висновки:
Запропоновані правила оформлення коду спрямовані на покращення його читабельності, підтримуваності та надійності. Дотримання принципів узгодженості в іменах, 
правильному використанні інтерфейсів, обробці помилок і управлінні ресурсами допомагає знижувати складність програми, роблячи її зрозумілішою для інших розробників. 
Такі підходи сприяють створенню коду, який легше тестувати, підтримувати та розвивати, що в кінцевому підсумку підвищує ефективність роботи програмного коду 
і знижує ризик помилок. Вони також допомагають уникати типових помилок, таких як витоки пам’яті або незрозуміле поводження з помилками, створюючи більш стабільні 
і масштабовані рішення. Раціональне використання ресурсів і правильна обробка помилок роблять програму стабільнішою, а інкапсуляція й чітка структура спрощують 
тестування та розвиток системи.


Використані джерела:

1. “Go Code Simplified” 
https://medium.com/@srajsonu/go-code-simplified-best-practices-design-patterns-clean-code-principles-and-package-management-bfea9c2d23dc
2. “Software Design Principles in Go” 
https://articles.readytowork.jp/software-design-principles-in-go-building-robust-and-maintainable-code-d2e94d713535
3. “Go Style Best Practices” 
https://google.github.io/styleguide/go/best-practices.html
4. “Effective Go” 
https://go.dev/doc/effective_go
5. “Go Design Patterns” 
https://softwarepatternslexicon.com/patterns-go/


Додаток А


Рисунок А.1 – Титульний слайд презентації

 
Рисунок А.2 – Слайд зі зміст презентації

 
Рисунок А.3 – Слайд  про особливості мови Go

 
Рисунок А.4 – Слайд з першою рекомендацією "Називайте інтерфейси відповідно до їхньої поведінки"

 
Рисунок А.5 – Слайд з другою рекомендацією "Уникайте префіксу Get у геттерах"

 
Рисунок А.6 – Слайд з третьою рекомендацією "Завжди обробляйте помилки"


Рисунок А.7 – Слайд з четвертою рекомендацією "Не використовуйте panic для звичайної обробки помилок"

 
Рисунок А.8 – Слайд з п'ятою рекомендацією "Будьте обережні при копіюванні структур"

 
Рисунок А.9 – Слайд з шостою рекомендацією "Експортуйте лише необхідні інтерфейси"

 
Рисунок А.10 – Слайд з сьомою рекомендацією "Використовуйте Must функції лише для критичної ініціалізації"

 
Рисунок А.11 – Слайд з восьмою рекомендацією "Завжди закривайте ресурси за допомогою defer"

 
Рисунок А.12 – Слайд с загальними висновками

 
Рисунок А.13 – Слайд зі списком використаних джерел
